{"ast":null,"code":"import { GoogleGenerativeAI } from '@google/generative-ai';\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\nexport const initializeGoogleAI = apiKey => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  genAI = new GoogleGenerativeAI(apiKey);\n  return genAI;\n};\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n  try {\n    const model = genAI.getGenerativeModel({\n      model: MODEL_ID\n    });\n\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call\n    const contents = [];\n\n    // Add previous image if provided\n    if (previousImage) {\n      contents.push(fullPrompt);\n      contents.push(previousImage);\n    } else {\n      contents.push(fullPrompt);\n    }\n\n    // Generate content with both text and image modalities\n    const result = await model.generateContent({\n      contents,\n      generationConfig: {\n        responseModalities: ['Text', 'Image']\n      }\n    });\n    const response = result.response;\n\n    // Extract text and image from the response\n    let text = null;\n    let image = null;\n    if (response.candidates && response.candidates.length > 0) {\n      const candidate = response.candidates[0];\n      if (candidate.content && candidate.content.parts) {\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            text = (text || '') + part.text;\n          }\n\n          // Handle image data\n          if (part.inlineData || part.data) {\n            // Convert base64 data to blob URL\n            const imageData = part.inlineData || part;\n            if (imageData.data && imageData.mimeType) {\n              try {\n                // Create blob from base64 data\n                const byteCharacters = atob(imageData.data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                  byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], {\n                  type: imageData.mimeType\n                });\n\n                // Create object URL for the blob\n                image = URL.createObjectURL(blob);\n              } catch (error) {\n                console.error('Error processing image data:', error);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n        const imageOnlyResult = await model.generateContent({\n          contents: [text],\n          generationConfig: {\n            responseModalities: ['Image']\n          }\n        });\n        const imageResponse = imageOnlyResult.response;\n        if (imageResponse.candidates && imageResponse.candidates.length > 0) {\n          const candidate = imageResponse.candidates[0];\n          if (candidate.content && candidate.content.parts) {\n            for (const part of candidate.content.parts) {\n              if (part.inlineData || part.data) {\n                const imageData = part.inlineData || part;\n                if (imageData.data && imageData.mimeType) {\n                  try {\n                    const byteCharacters = atob(imageData.data);\n                    const byteNumbers = new Array(byteCharacters.length);\n                    for (let i = 0; i < byteCharacters.length; i++) {\n                      byteNumbers[i] = byteCharacters.charCodeAt(i);\n                    }\n                    const byteArray = new Uint8Array(byteNumbers);\n                    const blob = new Blob([byteArray], {\n                      type: imageData.mimeType\n                    });\n                    image = URL.createObjectURL(blob);\n                    console.log('Fallback image generation succeeded');\n                    break;\n                  } catch (error) {\n                    console.error('Error processing fallback image data:', error);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n    return {\n      text,\n      image\n    };\n  } catch (error) {\n    console.error('Error generating content:', error);\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\nexport const isInitialized = () => {\n  return genAI !== null;\n};","map":{"version":3,"names":["GoogleGenerativeAI","MODEL_ID","genAI","initializeGoogleAI","apiKey","Error","generateContent","prompt","context","previousImage","style","model","getGenerativeModel","fullPrompt","contents","push","result","generationConfig","responseModalities","response","text","image","candidates","length","candidate","content","parts","part","inlineData","data","imageData","mimeType","byteCharacters","atob","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","blob","Blob","type","URL","createObjectURL","error","console","log","imageOnlyResult","imageResponse","fallbackError","message","includes","isInitialized"],"sources":["/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/src/utils/googleAI.js"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\n\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\n\nexport const initializeGoogleAI = (apiKey) => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  genAI = new GoogleGenerativeAI(apiKey);\n  return genAI;\n};\n\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n\n  try {\n    const model = genAI.getGenerativeModel({ model: MODEL_ID });\n\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call\n    const contents = [];\n\n    // Add previous image if provided\n    if (previousImage) {\n      contents.push(fullPrompt);\n      contents.push(previousImage);\n    } else {\n      contents.push(fullPrompt);\n    }\n\n    // Generate content with both text and image modalities\n    const result = await model.generateContent({\n      contents,\n      generationConfig: {\n        responseModalities: ['Text', 'Image']\n      }\n    });\n\n    const response = result.response;\n\n    // Extract text and image from the response\n    let text = null;\n    let image = null;\n\n    if (response.candidates && response.candidates.length > 0) {\n      const candidate = response.candidates[0];\n\n      if (candidate.content && candidate.content.parts) {\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            text = (text || '') + part.text;\n          }\n\n          // Handle image data\n          if (part.inlineData || part.data) {\n            // Convert base64 data to blob URL\n            const imageData = part.inlineData || part;\n            if (imageData.data && imageData.mimeType) {\n              try {\n                // Create blob from base64 data\n                const byteCharacters = atob(imageData.data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                  byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], { type: imageData.mimeType });\n\n                // Create object URL for the blob\n                image = URL.createObjectURL(blob);\n              } catch (error) {\n                console.error('Error processing image data:', error);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n\n        const imageOnlyResult = await model.generateContent({\n          contents: [text],\n          generationConfig: {\n            responseModalities: ['Image']\n          }\n        });\n\n        const imageResponse = imageOnlyResult.response;\n\n        if (imageResponse.candidates && imageResponse.candidates.length > 0) {\n          const candidate = imageResponse.candidates[0];\n\n          if (candidate.content && candidate.content.parts) {\n            for (const part of candidate.content.parts) {\n              if (part.inlineData || part.data) {\n                const imageData = part.inlineData || part;\n                if (imageData.data && imageData.mimeType) {\n                  try {\n                    const byteCharacters = atob(imageData.data);\n                    const byteNumbers = new Array(byteCharacters.length);\n                    for (let i = 0; i < byteCharacters.length; i++) {\n                      byteNumbers[i] = byteCharacters.charCodeAt(i);\n                    }\n                    const byteArray = new Uint8Array(byteNumbers);\n                    const blob = new Blob([byteArray], { type: imageData.mimeType });\n                    image = URL.createObjectURL(blob);\n                    console.log('Fallback image generation succeeded');\n                    break;\n                  } catch (error) {\n                    console.error('Error processing fallback image data:', error);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n\n    return { text, image };\n\n  } catch (error) {\n    console.error('Error generating content:', error);\n\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\n\nexport const isInitialized = () => {\n  return genAI !== null;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}