{"ast":null,"code":"import _objectSpread from\"/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{useState,useEffect}from'react';import ConversationDisplay from'./ConversationDisplay';import InitialSetup from'./InitialSetup';import{jsx as _jsx}from\"react/jsx-runtime\";const MainArea=_ref=>{let{conversation,setConversation,currentTurn,setCurrentTurn,style,initialImage,onInitialImageUpload,isApiKeySet,isLoading,setIsLoading,error,setError,success,setSuccess,onClearMessages}=_ref;const[initialPrompt,setInitialPrompt]=useState('');const[uploadedFile,setUploadedFile]=useState(null);// Handle undo last turn\nuseEffect(()=>{const handleUndo=()=>{if(conversation.length>0){const lastTurn=conversation[conversation.length-1];// Clean up blob URLs to prevent memory leaks\nif(lastTurn.image){URL.revokeObjectURL(lastTurn.image);}setConversation(prev=>prev.slice(0,-1));setCurrentTurn(prev=>Math.max(0,prev-1));setSuccess('Last turn undone successfully!');setTimeout(()=>setSuccess(null),3000);}};window.addEventListener('undoLastTurn',handleUndo);return()=>window.removeEventListener('undoLastTurn',handleUndo);},[conversation,setConversation,setCurrentTurn,setSuccess]);// Handle initial image upload\nconst handleFileUpload=file=>{setUploadedFile(file);onInitialImageUpload(file);};// Handle starting the evolution\nconst handleStartEvolution=async()=>{if(!initialPrompt.trim()){setError('Please enter an initial prompt');return;}if(!isApiKeySet){setError('Please set your API key first');return;}setIsLoading(true);setError(null);onClearMessages();try{// Add human input as turn 0\nconst humanTurn={id:Date.now(),model_name:'Human Input',text:initialPrompt,image:uploadedFile?URL.createObjectURL(uploadedFile):null,image_description:uploadedFile?\"Initial uploaded image\":null,prompt:null,timestamp:new Date().toLocaleTimeString(),style:style};setConversation([humanTurn]);setCurrentTurn(1);// Generate first AI turn\nawait generateNextTurn([humanTurn],1,initialPrompt,uploadedFile);setSuccess('First image generated successfully!');setTimeout(()=>setSuccess(null),3000);}catch(error){setError(error.message);}finally{setIsLoading(false);}};// Handle continuing the evolution\nconst handleContinueEvolution=async()=>{if(!isApiKeySet){setError('Please set your API key first');return;}setIsLoading(true);setError(null);onClearMessages();try{await generateNextTurn(conversation,currentTurn,'',null);setSuccess(\"Turn \".concat(currentTurn+1,\" generated successfully!\"));setTimeout(()=>setSuccess(null),3000);}catch(error){setError(error.message);}finally{setIsLoading(false);}};// Core generation logic\nconst generateNextTurn=async function(currentConversation,turnNumber){let initialPromptText=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';let previousImageFile=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;const{generateContent}=await import('../utils/googleAI');let autoPrompt;let previousImage=null;if(turnNumber===1){// First generation: based on initial prompt\nautoPrompt=\"Generate an image based on this prompt: '\".concat(initialPromptText,\"'. Provide a description of the image.\");if(previousImageFile){// Convert File object to data URL if needed\nif(previousImageFile instanceof File){const reader=new FileReader();previousImage=await new Promise(resolve=>{reader.onload=e=>resolve(e.target.result);reader.readAsDataURL(previousImageFile);});}else{previousImage=previousImageFile;}}}else{// Subsequent turns: evolve from previous image\nautoPrompt=\"Based on the previous image, select one important detail for you independently of the rest of the image (e.g., a specific object, character, or element). Describe your choice in text and then create a new story, situation, anecdote or other idea in which that detail is preserved as a detail, not necessarily the main subject of the image. Then, generate a new image from your description, while keeping only this detail recognizable.\";// Find the most recent image\nfor(let i=currentConversation.length-1;i>=0;i--){if(currentConversation[i].image){// Convert blob URL back to File object if needed\n// This is a simplified version - in practice you might need to store the original file\npreviousImage=currentConversation[i].image;break;}}}const result=await generateContent(autoPrompt,'',previousImage,style);const newTurn={id:Date.now(),model_name:'Chief of Details',text:result.text,image:result.image,image_description:result.text,prompt:autoPrompt,timestamp:new Date().toLocaleTimeString(),style:style};setConversation(prev=>[...prev,newTurn]);setCurrentTurn(turnNumber+1);};// Handle regenerating a specific turn\nconst handleRegenerateTurn=async turnIndex=>{if(!isApiKeySet){setError('Please set your API key first');return;}setIsLoading(true);setError(null);onClearMessages();try{const{generateContent}=await import('../utils/googleAI');// Get the prompt from the turn to regenerate\nconst turnToRegenerate=conversation[turnIndex];const prompt=turnToRegenerate.prompt;// Find previous image\nlet previousImage=null;for(let i=turnIndex-1;i>=0;i--){if(conversation[i].image){previousImage=conversation[i].image;break;}}const result=await generateContent(prompt,'',previousImage,style);// Clean up old blob URL\nif(turnToRegenerate.image){URL.revokeObjectURL(turnToRegenerate.image);}const updatedTurn=_objectSpread(_objectSpread({},turnToRegenerate),{},{text:result.text,image:result.image,image_description:result.text,timestamp:new Date().toLocaleTimeString()});const newConversation=[...conversation];newConversation[turnIndex]=updatedTurn;setConversation(newConversation);setSuccess(\"Turn \".concat(turnIndex,\" regenerated successfully!\"));setTimeout(()=>setSuccess(null),3000);}catch(error){setError(error.message);}finally{setIsLoading(false);}};return/*#__PURE__*/_jsx(\"div\",{className:\"main-area\",children:conversation.length===0?/*#__PURE__*/_jsx(InitialSetup,{initialPrompt:initialPrompt,setInitialPrompt:setInitialPrompt,onFileUpload:handleFileUpload,uploadedFile:uploadedFile,initialImage:initialImage,onStartEvolution:handleStartEvolution,isApiKeySet:isApiKeySet,isLoading:isLoading,style:style}):/*#__PURE__*/_jsx(ConversationDisplay,{conversation:conversation,onContinue:handleContinueEvolution,onRegenerateTurn:handleRegenerateTurn,currentTurn:currentTurn,style:style,isLoading:isLoading,isApiKeySet:isApiKeySet})});};export default MainArea;","map":{"version":3,"names":["React","useState","useEffect","ConversationDisplay","InitialSetup","jsx","_jsx","MainArea","_ref","conversation","setConversation","currentTurn","setCurrentTurn","style","initialImage","onInitialImageUpload","isApiKeySet","isLoading","setIsLoading","error","setError","success","setSuccess","onClearMessages","initialPrompt","setInitialPrompt","uploadedFile","setUploadedFile","handleUndo","length","lastTurn","image","URL","revokeObjectURL","prev","slice","Math","max","setTimeout","window","addEventListener","removeEventListener","handleFileUpload","file","handleStartEvolution","trim","humanTurn","id","Date","now","model_name","text","createObjectURL","image_description","prompt","timestamp","toLocaleTimeString","generateNextTurn","message","handleContinueEvolution","concat","currentConversation","turnNumber","initialPromptText","arguments","undefined","previousImageFile","generateContent","autoPrompt","previousImage","File","reader","FileReader","Promise","resolve","onload","e","target","result","readAsDataURL","i","newTurn","handleRegenerateTurn","turnIndex","turnToRegenerate","updatedTurn","_objectSpread","newConversation","className","children","onFileUpload","onStartEvolution","onContinue","onRegenerateTurn"],"sources":["/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/src/components/MainArea.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport ConversationDisplay from './ConversationDisplay';\nimport InitialSetup from './InitialSetup';\n\nconst MainArea = ({\n  conversation,\n  setConversation,\n  currentTurn,\n  setCurrentTurn,\n  style,\n  initialImage,\n  onInitialImageUpload,\n  isApiKeySet,\n  isLoading,\n  setIsLoading,\n  error,\n  setError,\n  success,\n  setSuccess,\n  onClearMessages\n}) => {\n  const [initialPrompt, setInitialPrompt] = useState('');\n  const [uploadedFile, setUploadedFile] = useState(null);\n\n  // Handle undo last turn\n  useEffect(() => {\n    const handleUndo = () => {\n      if (conversation.length > 0) {\n        const lastTurn = conversation[conversation.length - 1];\n\n        // Clean up blob URLs to prevent memory leaks\n        if (lastTurn.image) {\n          URL.revokeObjectURL(lastTurn.image);\n        }\n\n        setConversation(prev => prev.slice(0, -1));\n        setCurrentTurn(prev => Math.max(0, prev - 1));\n        setSuccess('Last turn undone successfully!');\n        setTimeout(() => setSuccess(null), 3000);\n      }\n    };\n\n    window.addEventListener('undoLastTurn', handleUndo);\n    return () => window.removeEventListener('undoLastTurn', handleUndo);\n  }, [conversation, setConversation, setCurrentTurn, setSuccess]);\n\n  // Handle initial image upload\n  const handleFileUpload = (file) => {\n    setUploadedFile(file);\n    onInitialImageUpload(file);\n  };\n\n  // Handle starting the evolution\n  const handleStartEvolution = async () => {\n    if (!initialPrompt.trim()) {\n      setError('Please enter an initial prompt');\n      return;\n    }\n\n    if (!isApiKeySet) {\n      setError('Please set your API key first');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    onClearMessages();\n\n    try {\n      // Add human input as turn 0\n      const humanTurn = {\n        id: Date.now(),\n        model_name: 'Human Input',\n        text: initialPrompt,\n        image: uploadedFile ? URL.createObjectURL(uploadedFile) : null,\n        image_description: uploadedFile ? \"Initial uploaded image\" : null,\n        prompt: null,\n        timestamp: new Date().toLocaleTimeString(),\n        style: style\n      };\n\n      setConversation([humanTurn]);\n      setCurrentTurn(1);\n\n      // Generate first AI turn\n      await generateNextTurn([humanTurn], 1, initialPrompt, uploadedFile);\n\n      setSuccess('First image generated successfully!');\n      setTimeout(() => setSuccess(null), 3000);\n    } catch (error) {\n      setError(error.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Handle continuing the evolution\n  const handleContinueEvolution = async () => {\n    if (!isApiKeySet) {\n      setError('Please set your API key first');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    onClearMessages();\n\n    try {\n      await generateNextTurn(conversation, currentTurn, '', null);\n      setSuccess(`Turn ${currentTurn + 1} generated successfully!`);\n      setTimeout(() => setSuccess(null), 3000);\n    } catch (error) {\n      setError(error.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Core generation logic\n  const generateNextTurn = async (currentConversation, turnNumber, initialPromptText = '', previousImageFile = null) => {\n    const { generateContent } = await import('../utils/googleAI');\n\n    let autoPrompt;\n    let previousImage = null;\n\n    if (turnNumber === 1) {\n      // First generation: based on initial prompt\n      autoPrompt = `Generate an image based on this prompt: '${initialPromptText}'. Provide a description of the image.`;\n      if (previousImageFile) {\n        // Convert File object to data URL if needed\n        if (previousImageFile instanceof File) {\n          const reader = new FileReader();\n          previousImage = await new Promise((resolve) => {\n            reader.onload = (e) => resolve(e.target.result);\n            reader.readAsDataURL(previousImageFile);\n          });\n        } else {\n          previousImage = previousImageFile;\n        }\n      }\n    } else {\n      // Subsequent turns: evolve from previous image\n      autoPrompt = \"Based on the previous image, select one important detail for you independently of the rest of the image (e.g., a specific object, character, or element). Describe your choice in text and then create a new story, situation, anecdote or other idea in which that detail is preserved as a detail, not necessarily the main subject of the image. Then, generate a new image from your description, while keeping only this detail recognizable.\";\n\n      // Find the most recent image\n      for (let i = currentConversation.length - 1; i >= 0; i--) {\n        if (currentConversation[i].image) {\n          // Convert blob URL back to File object if needed\n          // This is a simplified version - in practice you might need to store the original file\n          previousImage = currentConversation[i].image;\n          break;\n        }\n      }\n    }\n\n    const result = await generateContent(autoPrompt, '', previousImage, style);\n\n    const newTurn = {\n      id: Date.now(),\n      model_name: 'Chief of Details',\n      text: result.text,\n      image: result.image,\n      image_description: result.text,\n      prompt: autoPrompt,\n      timestamp: new Date().toLocaleTimeString(),\n      style: style\n    };\n\n    setConversation(prev => [...prev, newTurn]);\n    setCurrentTurn(turnNumber + 1);\n  };\n\n  // Handle regenerating a specific turn\n  const handleRegenerateTurn = async (turnIndex) => {\n    if (!isApiKeySet) {\n      setError('Please set your API key first');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    onClearMessages();\n\n    try {\n      const { generateContent } = await import('../utils/googleAI');\n\n      // Get the prompt from the turn to regenerate\n      const turnToRegenerate = conversation[turnIndex];\n      const prompt = turnToRegenerate.prompt;\n\n      // Find previous image\n      let previousImage = null;\n      for (let i = turnIndex - 1; i >= 0; i--) {\n        if (conversation[i].image) {\n          previousImage = conversation[i].image;\n          break;\n        }\n      }\n\n      const result = await generateContent(prompt, '', previousImage, style);\n\n      // Clean up old blob URL\n      if (turnToRegenerate.image) {\n        URL.revokeObjectURL(turnToRegenerate.image);\n      }\n\n      const updatedTurn = {\n        ...turnToRegenerate,\n        text: result.text,\n        image: result.image,\n        image_description: result.text,\n        timestamp: new Date().toLocaleTimeString()\n      };\n\n      const newConversation = [...conversation];\n      newConversation[turnIndex] = updatedTurn;\n      setConversation(newConversation);\n\n      setSuccess(`Turn ${turnIndex} regenerated successfully!`);\n      setTimeout(() => setSuccess(null), 3000);\n    } catch (error) {\n      setError(error.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"main-area\">\n      {conversation.length === 0 ? (\n        <InitialSetup\n          initialPrompt={initialPrompt}\n          setInitialPrompt={setInitialPrompt}\n          onFileUpload={handleFileUpload}\n          uploadedFile={uploadedFile}\n          initialImage={initialImage}\n          onStartEvolution={handleStartEvolution}\n          isApiKeySet={isApiKeySet}\n          isLoading={isLoading}\n          style={style}\n        />\n      ) : (\n        <ConversationDisplay\n          conversation={conversation}\n          onContinue={handleContinueEvolution}\n          onRegenerateTurn={handleRegenerateTurn}\n          currentTurn={currentTurn}\n          style={style}\n          isLoading={isLoading}\n          isApiKeySet={isApiKeySet}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default MainArea;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}