{"ast":null,"code":"import{GoogleGenAI}from\"@google/genai\";const MODEL_ID=\"gemini-2.5-flash-image-preview\";// Initialize the Google AI client\nlet genAI=null;let currentApiKey=null;export const initializeGoogleAI=apiKey=>{if(!apiKey){throw new Error('API key is required');}// Only reinitialize if the API key has changed\nif(currentApiKey!==apiKey){console.log('ðŸ”„ Initializing Google AI with new API key (override detected)');genAI=new GoogleGenAI({apiKey:apiKey});currentApiKey=apiKey;}else{console.log('âœ… Using existing Google AI client (same API key)');}return genAI;};export const generateContent=async function(prompt){let context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";let previousImage=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let style=arguments.length>3&&arguments[3]!==undefined?arguments[3]:\"\";if(!genAI){throw new Error('Google AI client not initialized. Please set your API key first.');}console.log('ðŸš€ Starting content generation with API key:',currentApiKey?currentApiKey.substring(0,8)+'...':'NO KEY');try{// Build the full prompt\nlet fullPrompt=context?\"\".concat(context,\"\\n\\n\").concat(prompt):prompt;if(style){fullPrompt+=\"\\nStyle: \".concat(style,\".\");}// Prepare contents for the API call (matching documentation exactly)\nlet contents;if(previousImage){try{// Convert blob URL or data URL to base64 for the API\nlet imageData,mimeType;if(previousImage.startsWith('data:')){// Handle data URL\nconst[mime,data]=previousImage.split(',');mimeType=mime.split(':')[1].split(';')[0];imageData=data;}else if(previousImage.startsWith('blob:')){// Handle blob URL - we need to fetch and convert\nconst response=await fetch(previousImage);const blob=await response.blob();mimeType=blob.type;// Convert blob to base64\nconst reader=new FileReader();imageData=await new Promise(resolve=>{reader.onload=()=>resolve(reader.result.split(',')[1]);reader.readAsDataURL(blob);});}else{throw new Error('Unsupported image format');}// Format matching documentation for image+text\ncontents=[{text:fullPrompt},{inlineData:{mimeType:mimeType,data:imageData}}];}catch(error){console.error('Error processing previous image:',error);// Fall back to text-only if image processing fails\ncontents=fullPrompt;}}else{// Text-only format (matching documentation)\ncontents=fullPrompt;}// Generate content with image modality (matching documentation exactly)\nconst response=await genAI.models.generateContent({model:MODEL_ID,contents:contents});// Extract text and image from the response (matching documentation exactly)\nlet text=null;let image=null;for(const part of response.candidates[0].content.parts){if(part.text){text=(text||'')+part.text;}else if(part.inlineData){// Convert base64 data to blob URL (matching documentation)\nconst imageData=part.inlineData.data;const mimeType=part.inlineData.mimeType;try{// Create blob from base64 data\nconst byteCharacters=atob(imageData);const byteNumbers=new Array(byteCharacters.length);for(let i=0;i<byteCharacters.length;i++){byteNumbers[i]=byteCharacters.charCodeAt(i);}const byteArray=new Uint8Array(byteNumbers);const blob=new Blob([byteArray],{type:mimeType});// Create object URL for the blob\nimage=URL.createObjectURL(blob);}catch(error){console.error('Error processing image data:',error);}}}// If no image was found but we have text, try to generate image-only\nif(!image&&text){try{console.log('No image in initial response, attempting image-only generation...');const imageOnlyResponse=await genAI.models.generateContent({model:MODEL_ID,contents:text});// Handle fallback response (matching documentation)\nfor(const part of imageOnlyResponse.candidates[0].content.parts){if(part.inlineData){const imageData=part.inlineData.data;const mimeType=part.inlineData.mimeType;try{const byteCharacters=atob(imageData);const byteNumbers=new Array(byteCharacters.length);for(let i=0;i<byteCharacters.length;i++){byteNumbers[i]=byteCharacters.charCodeAt(i);}const byteArray=new Uint8Array(byteNumbers);const blob=new Blob([byteArray],{type:mimeType});image=URL.createObjectURL(blob);console.log('Fallback image generation succeeded');break;}catch(error){console.error('Error processing fallback image data:',error);}}}}catch(fallbackError){console.error('Fallback image generation failed:',fallbackError);}}return{text,image};}catch(error){console.error('Error generating content:',error);if(error.message&&error.message.includes('API_KEY_INVALID')){throw new Error('Invalid API key. Please check your Gemini API key.');}else if(error.message&&error.message.includes('QUOTA_EXCEEDED')){throw new Error('API quota exceeded. Please check your usage limits.');}else if(error.message&&error.message.includes('PERMISSION_DENIED')){throw new Error('Permission denied. Please check your API key permissions.');}else{throw new Error(\"Generation failed: \".concat(error.message||'Unknown error'));}}};export const isInitialized=()=>{return genAI!==null;};export const getCurrentApiKey=()=>{return currentApiKey;};","map":{"version":3,"names":["GoogleGenAI","MODEL_ID","genAI","currentApiKey","initializeGoogleAI","apiKey","Error","console","log","generateContent","prompt","context","arguments","length","undefined","previousImage","style","substring","fullPrompt","concat","contents","imageData","mimeType","startsWith","mime","data","split","response","fetch","blob","type","reader","FileReader","Promise","resolve","onload","result","readAsDataURL","text","inlineData","error","models","model","image","part","candidates","content","parts","byteCharacters","atob","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","Blob","URL","createObjectURL","imageOnlyResponse","fallbackError","message","includes","isInitialized","getCurrentApiKey"],"sources":["/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/src/utils/googleAI.js"],"sourcesContent":["import { GoogleGenAI } from \"@google/genai\";\n\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\nlet currentApiKey = null;\n\nexport const initializeGoogleAI = (apiKey) => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n\n  // Only reinitialize if the API key has changed\n  if (currentApiKey !== apiKey) {\n    console.log('ðŸ”„ Initializing Google AI with new API key (override detected)');\n    genAI = new GoogleGenAI({\n      apiKey: apiKey\n    });\n    currentApiKey = apiKey;\n  } else {\n    console.log('âœ… Using existing Google AI client (same API key)');\n  }\n\n  return genAI;\n};\n\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n\n  console.log('ðŸš€ Starting content generation with API key:', currentApiKey ? currentApiKey.substring(0, 8) + '...' : 'NO KEY');\n\n  try {\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call (matching documentation exactly)\n    let contents;\n\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise((resolve) => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        // Format matching documentation for image+text\n        contents = [\n          { text: fullPrompt },\n          {\n            inlineData: {\n              mimeType: mimeType,\n              data: imageData\n            }\n          }\n        ];\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Fall back to text-only if image processing fails\n        contents = fullPrompt;\n      }\n    } else {\n      // Text-only format (matching documentation)\n      contents = fullPrompt;\n    }\n\n    // Generate content with image modality (matching documentation exactly)\n    const response = await genAI.models.generateContent({\n      model: MODEL_ID,\n      contents: contents,\n    });\n\n    // Extract text and image from the response (matching documentation exactly)\n    let text = null;\n    let image = null;\n\n    for (const part of response.candidates[0].content.parts) {\n      if (part.text) {\n        text = (text || '') + part.text;\n      } else if (part.inlineData) {\n        // Convert base64 data to blob URL (matching documentation)\n        const imageData = part.inlineData.data;\n        const mimeType = part.inlineData.mimeType;\n\n        try {\n          // Create blob from base64 data\n          const byteCharacters = atob(imageData);\n          const byteNumbers = new Array(byteCharacters.length);\n          for (let i = 0; i < byteCharacters.length; i++) {\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\n          }\n          const byteArray = new Uint8Array(byteNumbers);\n          const blob = new Blob([byteArray], { type: mimeType });\n\n          // Create object URL for the blob\n          image = URL.createObjectURL(blob);\n        } catch (error) {\n          console.error('Error processing image data:', error);\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n\n        const imageOnlyResponse = await genAI.models.generateContent({\n          model: MODEL_ID,\n          contents: text,\n        });\n\n        // Handle fallback response (matching documentation)\n        for (const part of imageOnlyResponse.candidates[0].content.parts) {\n          if (part.inlineData) {\n            const imageData = part.inlineData.data;\n            const mimeType = part.inlineData.mimeType;\n\n            try {\n              const byteCharacters = atob(imageData);\n              const byteNumbers = new Array(byteCharacters.length);\n              for (let i = 0; i < byteCharacters.length; i++) {\n                byteNumbers[i] = byteCharacters.charCodeAt(i);\n              }\n              const byteArray = new Uint8Array(byteNumbers);\n              const blob = new Blob([byteArray], { type: mimeType });\n              image = URL.createObjectURL(blob);\n              console.log('Fallback image generation succeeded');\n              break;\n            } catch (error) {\n              console.error('Error processing fallback image data:', error);\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n\n    return { text, image };\n\n  } catch (error) {\n    console.error('Error generating content:', error);\n\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\n\nexport const isInitialized = () => {\n  return genAI !== null;\n};\n\nexport const getCurrentApiKey = () => {\n  return currentApiKey;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}