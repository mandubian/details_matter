{"ast":null,"code":"import { GoogleGenAI } from \"@google/genai\";\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\nlet currentApiKey = null;\nexport const initializeGoogleAI = apiKey => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n\n  // Only reinitialize if the API key has changed\n  if (currentApiKey !== apiKey) {\n    console.log('ðŸ”„ Initializing Google AI with new API key (override detected)');\n    genAI = new GoogleGenAI({\n      apiKey: apiKey\n    });\n    currentApiKey = apiKey;\n  } else {\n    console.log('âœ… Using existing Google AI client (same API key)');\n  }\n  return genAI;\n};\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n  console.log('ðŸš€ Starting content generation with API key:', currentApiKey ? currentApiKey.substring(0, 8) + '...' : 'NO KEY');\n  try {\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call (matching documentation exactly)\n    let contents;\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise(resolve => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        // Format matching documentation for image+text\n        contents = [{\n          text: fullPrompt\n        }, {\n          inlineData: {\n            mimeType: mimeType,\n            data: imageData\n          }\n        }];\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Fall back to text-only if image processing fails\n        contents = fullPrompt;\n      }\n    } else {\n      // Text-only format (matching documentation)\n      contents = fullPrompt;\n    }\n\n    // Generate content with image modality (matching documentation exactly)\n    const response = await genAI.models.generateContent({\n      model: MODEL_ID,\n      contents: contents\n    });\n\n    // Extract text and image from the response (matching documentation exactly)\n    let text = null;\n    let image = null;\n    for (const part of response.candidates[0].content.parts) {\n      if (part.text) {\n        text = (text || '') + part.text;\n      } else if (part.inlineData) {\n        // Convert base64 data to blob URL (matching documentation)\n        const imageData = part.inlineData.data;\n        const mimeType = part.inlineData.mimeType;\n        try {\n          // Create blob from base64 data\n          const byteCharacters = atob(imageData);\n          const byteNumbers = new Array(byteCharacters.length);\n          for (let i = 0; i < byteCharacters.length; i++) {\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\n          }\n          const byteArray = new Uint8Array(byteNumbers);\n          const blob = new Blob([byteArray], {\n            type: mimeType\n          });\n\n          // Create object URL for the blob\n          image = URL.createObjectURL(blob);\n        } catch (error) {\n          console.error('Error processing image data:', error);\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n        const imageOnlyResponse = await genAI.models.generateContent({\n          model: MODEL_ID,\n          contents: text\n        });\n\n        // Handle fallback response (matching documentation)\n        for (const part of imageOnlyResponse.candidates[0].content.parts) {\n          if (part.inlineData) {\n            const imageData = part.inlineData.data;\n            const mimeType = part.inlineData.mimeType;\n            try {\n              const byteCharacters = atob(imageData);\n              const byteNumbers = new Array(byteCharacters.length);\n              for (let i = 0; i < byteCharacters.length; i++) {\n                byteNumbers[i] = byteCharacters.charCodeAt(i);\n              }\n              const byteArray = new Uint8Array(byteNumbers);\n              const blob = new Blob([byteArray], {\n                type: mimeType\n              });\n              image = URL.createObjectURL(blob);\n              console.log('Fallback image generation succeeded');\n              break;\n            } catch (error) {\n              console.error('Error processing fallback image data:', error);\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n    return {\n      text,\n      image\n    };\n  } catch (error) {\n    console.error('Error generating content:', error);\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\nexport const isInitialized = () => {\n  return genAI !== null;\n};\nexport const getCurrentApiKey = () => {\n  return currentApiKey;\n};","map":{"version":3,"names":["GoogleGenAI","MODEL_ID","genAI","currentApiKey","initializeGoogleAI","apiKey","Error","console","log","generateContent","prompt","context","previousImage","style","substring","fullPrompt","contents","imageData","mimeType","startsWith","mime","data","split","response","fetch","blob","type","reader","FileReader","Promise","resolve","onload","result","readAsDataURL","text","inlineData","error","models","model","image","part","candidates","content","parts","byteCharacters","atob","byteNumbers","Array","length","i","charCodeAt","byteArray","Uint8Array","Blob","URL","createObjectURL","imageOnlyResponse","fallbackError","message","includes","isInitialized","getCurrentApiKey"],"sources":["/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/src/utils/googleAI.js"],"sourcesContent":["import { GoogleGenAI } from \"@google/genai\";\n\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\nlet currentApiKey = null;\n\nexport const initializeGoogleAI = (apiKey) => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n\n  // Only reinitialize if the API key has changed\n  if (currentApiKey !== apiKey) {\n    console.log('ðŸ”„ Initializing Google AI with new API key (override detected)');\n    genAI = new GoogleGenAI({\n      apiKey: apiKey\n    });\n    currentApiKey = apiKey;\n  } else {\n    console.log('âœ… Using existing Google AI client (same API key)');\n  }\n\n  return genAI;\n};\n\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n\n  console.log('ðŸš€ Starting content generation with API key:', currentApiKey ? currentApiKey.substring(0, 8) + '...' : 'NO KEY');\n\n  try {\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call (matching documentation exactly)\n    let contents;\n\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise((resolve) => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        // Format matching documentation for image+text\n        contents = [\n          { text: fullPrompt },\n          {\n            inlineData: {\n              mimeType: mimeType,\n              data: imageData\n            }\n          }\n        ];\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Fall back to text-only if image processing fails\n        contents = fullPrompt;\n      }\n    } else {\n      // Text-only format (matching documentation)\n      contents = fullPrompt;\n    }\n\n    // Generate content with image modality (matching documentation exactly)\n    const response = await genAI.models.generateContent({\n      model: MODEL_ID,\n      contents: contents,\n    });\n\n    // Extract text and image from the response (matching documentation exactly)\n    let text = null;\n    let image = null;\n\n    for (const part of response.candidates[0].content.parts) {\n      if (part.text) {\n        text = (text || '') + part.text;\n      } else if (part.inlineData) {\n        // Convert base64 data to blob URL (matching documentation)\n        const imageData = part.inlineData.data;\n        const mimeType = part.inlineData.mimeType;\n\n        try {\n          // Create blob from base64 data\n          const byteCharacters = atob(imageData);\n          const byteNumbers = new Array(byteCharacters.length);\n          for (let i = 0; i < byteCharacters.length; i++) {\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\n          }\n          const byteArray = new Uint8Array(byteNumbers);\n          const blob = new Blob([byteArray], { type: mimeType });\n\n          // Create object URL for the blob\n          image = URL.createObjectURL(blob);\n        } catch (error) {\n          console.error('Error processing image data:', error);\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n\n        const imageOnlyResponse = await genAI.models.generateContent({\n          model: MODEL_ID,\n          contents: text,\n        });\n\n        // Handle fallback response (matching documentation)\n        for (const part of imageOnlyResponse.candidates[0].content.parts) {\n          if (part.inlineData) {\n            const imageData = part.inlineData.data;\n            const mimeType = part.inlineData.mimeType;\n\n            try {\n              const byteCharacters = atob(imageData);\n              const byteNumbers = new Array(byteCharacters.length);\n              for (let i = 0; i < byteCharacters.length; i++) {\n                byteNumbers[i] = byteCharacters.charCodeAt(i);\n              }\n              const byteArray = new Uint8Array(byteNumbers);\n              const blob = new Blob([byteArray], { type: mimeType });\n              image = URL.createObjectURL(blob);\n              console.log('Fallback image generation succeeded');\n              break;\n            } catch (error) {\n              console.error('Error processing fallback image data:', error);\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n\n    return { text, image };\n\n  } catch (error) {\n    console.error('Error generating content:', error);\n\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\n\nexport const isInitialized = () => {\n  return genAI !== null;\n};\n\nexport const getCurrentApiKey = () => {\n  return currentApiKey;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}