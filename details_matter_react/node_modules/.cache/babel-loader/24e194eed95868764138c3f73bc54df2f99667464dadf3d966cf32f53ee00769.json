{"ast":null,"code":"import { GoogleGenAI } from \"@google/genai\";\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\nexport const initializeGoogleAI = apiKey => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  // Initialize with API key in environment or constructor\n  genAI = new GoogleGenAI({\n    apiKey: apiKey\n  });\n  return genAI;\n};\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n  try {\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call (matching documentation exactly)\n    let contents;\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise(resolve => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        // Format matching documentation for image+text\n        contents = [{\n          text: fullPrompt\n        }, {\n          inlineData: {\n            mimeType: mimeType,\n            data: imageData\n          }\n        }];\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Fall back to text-only if image processing fails\n        contents = fullPrompt;\n      }\n    } else {\n      // Text-only format (matching documentation)\n      contents = fullPrompt;\n    }\n\n    // Generate content with image modality (matching documentation exactly)\n    const response = await genAI.models.generateContent({\n      model: MODEL_ID,\n      contents: contents\n    });\n\n    // Extract text and image from the response (matching documentation exactly)\n    let text = null;\n    let image = null;\n    for (const part of response.candidates[0].content.parts) {\n      if (part.text) {\n        text = (text || '') + part.text;\n      } else if (part.inlineData) {\n        // Convert base64 data to blob URL (matching documentation)\n        const imageData = part.inlineData.data;\n        const mimeType = part.inlineData.mimeType;\n        try {\n          // Create blob from base64 data\n          const byteCharacters = atob(imageData);\n          const byteNumbers = new Array(byteCharacters.length);\n          for (let i = 0; i < byteCharacters.length; i++) {\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\n          }\n          const byteArray = new Uint8Array(byteNumbers);\n          const blob = new Blob([byteArray], {\n            type: mimeType\n          });\n\n          // Create object URL for the blob\n          image = URL.createObjectURL(blob);\n        } catch (error) {\n          console.error('Error processing image data:', error);\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n        const imageOnlyResponse = await genAI.models.generateContent({\n          model: MODEL_ID,\n          contents: text\n        });\n\n        // Handle fallback response (matching documentation)\n        for (const part of imageOnlyResponse.candidates[0].content.parts) {\n          if (part.inlineData) {\n            const imageData = part.inlineData.data;\n            const mimeType = part.inlineData.mimeType;\n            try {\n              const byteCharacters = atob(imageData);\n              const byteNumbers = new Array(byteCharacters.length);\n              for (let i = 0; i < byteCharacters.length; i++) {\n                byteNumbers[i] = byteCharacters.charCodeAt(i);\n              }\n              const byteArray = new Uint8Array(byteNumbers);\n              const blob = new Blob([byteArray], {\n                type: mimeType\n              });\n              image = URL.createObjectURL(blob);\n              console.log('Fallback image generation succeeded');\n              break;\n            } catch (error) {\n              console.error('Error processing fallback image data:', error);\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n    return {\n      text,\n      image\n    };\n  } catch (error) {\n    console.error('Error generating content:', error);\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\nexport const isInitialized = () => {\n  return genAI !== null;\n};","map":{"version":3,"names":["GoogleGenAI","MODEL_ID","genAI","initializeGoogleAI","apiKey","Error","generateContent","prompt","context","previousImage","style","fullPrompt","contents","imageData","mimeType","startsWith","mime","data","split","response","fetch","blob","type","reader","FileReader","Promise","resolve","onload","result","readAsDataURL","text","inlineData","error","console","models","model","image","part","candidates","content","parts","byteCharacters","atob","byteNumbers","Array","length","i","charCodeAt","byteArray","Uint8Array","Blob","URL","createObjectURL","log","imageOnlyResponse","fallbackError","message","includes","isInitialized"],"sources":["/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/src/utils/googleAI.js"],"sourcesContent":["import { GoogleGenAI } from \"@google/genai\";\n\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\n\nexport const initializeGoogleAI = (apiKey) => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  // Initialize with API key in environment or constructor\n  genAI = new GoogleGenAI({\n    apiKey: apiKey\n  });\n  return genAI;\n};\n\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n\n  try {\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call (matching documentation exactly)\n    let contents;\n\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise((resolve) => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        // Format matching documentation for image+text\n        contents = [\n          { text: fullPrompt },\n          {\n            inlineData: {\n              mimeType: mimeType,\n              data: imageData\n            }\n          }\n        ];\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Fall back to text-only if image processing fails\n        contents = fullPrompt;\n      }\n    } else {\n      // Text-only format (matching documentation)\n      contents = fullPrompt;\n    }\n\n    // Generate content with image modality (matching documentation exactly)\n    const response = await genAI.models.generateContent({\n      model: MODEL_ID,\n      contents: contents,\n    });\n\n    // Extract text and image from the response (matching documentation exactly)\n    let text = null;\n    let image = null;\n\n    for (const part of response.candidates[0].content.parts) {\n      if (part.text) {\n        text = (text || '') + part.text;\n      } else if (part.inlineData) {\n        // Convert base64 data to blob URL (matching documentation)\n        const imageData = part.inlineData.data;\n        const mimeType = part.inlineData.mimeType;\n\n        try {\n          // Create blob from base64 data\n          const byteCharacters = atob(imageData);\n          const byteNumbers = new Array(byteCharacters.length);\n          for (let i = 0; i < byteCharacters.length; i++) {\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\n          }\n          const byteArray = new Uint8Array(byteNumbers);\n          const blob = new Blob([byteArray], { type: mimeType });\n\n          // Create object URL for the blob\n          image = URL.createObjectURL(blob);\n        } catch (error) {\n          console.error('Error processing image data:', error);\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n\n        const imageOnlyResponse = await genAI.models.generateContent({\n          model: MODEL_ID,\n          contents: text,\n        });\n\n        // Handle fallback response (matching documentation)\n        for (const part of imageOnlyResponse.candidates[0].content.parts) {\n          if (part.inlineData) {\n            const imageData = part.inlineData.data;\n            const mimeType = part.inlineData.mimeType;\n\n            try {\n              const byteCharacters = atob(imageData);\n              const byteNumbers = new Array(byteCharacters.length);\n              for (let i = 0; i < byteCharacters.length; i++) {\n                byteNumbers[i] = byteCharacters.charCodeAt(i);\n              }\n              const byteArray = new Uint8Array(byteNumbers);\n              const blob = new Blob([byteArray], { type: mimeType });\n              image = URL.createObjectURL(blob);\n              console.log('Fallback image generation succeeded');\n              break;\n            } catch (error) {\n              console.error('Error processing fallback image data:', error);\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n\n    return { text, image };\n\n  } catch (error) {\n    console.error('Error generating content:', error);\n\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\n\nexport const isInitialized = () => {\n  return genAI !== null;\n};\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,eAAe;AAE3C,MAAMC,QAAQ,GAAG,gCAAgC;;AAEjD;AACA,IAAIC,KAAK,GAAG,IAAI;AAEhB,OAAO,MAAMC,kBAAkB,GAAIC,MAAM,IAAK;EAC5C,IAAI,CAACA,MAAM,EAAE;IACX,MAAM,IAAIC,KAAK,CAAC,qBAAqB,CAAC;EACxC;EACA;EACAH,KAAK,GAAG,IAAIF,WAAW,CAAC;IACtBI,MAAM,EAAEA;EACV,CAAC,CAAC;EACF,OAAOF,KAAK;AACd,CAAC;AAED,OAAO,MAAMI,eAAe,GAAG,MAAAA,CAAOC,MAAM,EAAEC,OAAO,GAAG,EAAE,EAAEC,aAAa,GAAG,IAAI,EAAEC,KAAK,GAAG,EAAE,KAAK;EAC/F,IAAI,CAACR,KAAK,EAAE;IACV,MAAM,IAAIG,KAAK,CAAC,kEAAkE,CAAC;EACrF;EAEA,IAAI;IACF;IACA,IAAIM,UAAU,GAAGH,OAAO,GAAG,GAAGA,OAAO,OAAOD,MAAM,EAAE,GAAGA,MAAM;IAC7D,IAAIG,KAAK,EAAE;MACTC,UAAU,IAAI,YAAYD,KAAK,GAAG;IACpC;;IAEA;IACA,IAAIE,QAAQ;IAEZ,IAAIH,aAAa,EAAE;MACjB,IAAI;QACF;QACA,IAAII,SAAS,EAAEC,QAAQ;QAEvB,IAAIL,aAAa,CAACM,UAAU,CAAC,OAAO,CAAC,EAAE;UACrC;UACA,MAAM,CAACC,IAAI,EAAEC,IAAI,CAAC,GAAGR,aAAa,CAACS,KAAK,CAAC,GAAG,CAAC;UAC7CJ,QAAQ,GAAGE,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UAC3CL,SAAS,GAAGI,IAAI;QAClB,CAAC,MAAM,IAAIR,aAAa,CAACM,UAAU,CAAC,OAAO,CAAC,EAAE;UAC5C;UACA,MAAMI,QAAQ,GAAG,MAAMC,KAAK,CAACX,aAAa,CAAC;UAC3C,MAAMY,IAAI,GAAG,MAAMF,QAAQ,CAACE,IAAI,CAAC,CAAC;UAClCP,QAAQ,GAAGO,IAAI,CAACC,IAAI;;UAEpB;UACA,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;UAC/BX,SAAS,GAAG,MAAM,IAAIY,OAAO,CAAEC,OAAO,IAAK;YACzCH,MAAM,CAACI,MAAM,GAAG,MAAMD,OAAO,CAACH,MAAM,CAACK,MAAM,CAACV,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAC1DK,MAAM,CAACM,aAAa,CAACR,IAAI,CAAC;UAC5B,CAAC,CAAC;QACJ,CAAC,MAAM;UACL,MAAM,IAAIhB,KAAK,CAAC,0BAA0B,CAAC;QAC7C;;QAEA;QACAO,QAAQ,GAAG,CACT;UAAEkB,IAAI,EAAEnB;QAAW,CAAC,EACpB;UACEoB,UAAU,EAAE;YACVjB,QAAQ,EAAEA,QAAQ;YAClBG,IAAI,EAAEJ;UACR;QACF,CAAC,CACF;MACH,CAAC,CAAC,OAAOmB,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;QACxD;QACApB,QAAQ,GAAGD,UAAU;MACvB;IACF,CAAC,MAAM;MACL;MACAC,QAAQ,GAAGD,UAAU;IACvB;;IAEA;IACA,MAAMQ,QAAQ,GAAG,MAAMjB,KAAK,CAACgC,MAAM,CAAC5B,eAAe,CAAC;MAClD6B,KAAK,EAAElC,QAAQ;MACfW,QAAQ,EAAEA;IACZ,CAAC,CAAC;;IAEF;IACA,IAAIkB,IAAI,GAAG,IAAI;IACf,IAAIM,KAAK,GAAG,IAAI;IAEhB,KAAK,MAAMC,IAAI,IAAIlB,QAAQ,CAACmB,UAAU,CAAC,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,EAAE;MACvD,IAAIH,IAAI,CAACP,IAAI,EAAE;QACbA,IAAI,GAAG,CAACA,IAAI,IAAI,EAAE,IAAIO,IAAI,CAACP,IAAI;MACjC,CAAC,MAAM,IAAIO,IAAI,CAACN,UAAU,EAAE;QAC1B;QACA,MAAMlB,SAAS,GAAGwB,IAAI,CAACN,UAAU,CAACd,IAAI;QACtC,MAAMH,QAAQ,GAAGuB,IAAI,CAACN,UAAU,CAACjB,QAAQ;QAEzC,IAAI;UACF;UACA,MAAM2B,cAAc,GAAGC,IAAI,CAAC7B,SAAS,CAAC;UACtC,MAAM8B,WAAW,GAAG,IAAIC,KAAK,CAACH,cAAc,CAACI,MAAM,CAAC;UACpD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,cAAc,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;YAC9CH,WAAW,CAACG,CAAC,CAAC,GAAGL,cAAc,CAACM,UAAU,CAACD,CAAC,CAAC;UAC/C;UACA,MAAME,SAAS,GAAG,IAAIC,UAAU,CAACN,WAAW,CAAC;UAC7C,MAAMtB,IAAI,GAAG,IAAI6B,IAAI,CAAC,CAACF,SAAS,CAAC,EAAE;YAAE1B,IAAI,EAAER;UAAS,CAAC,CAAC;;UAEtD;UACAsB,KAAK,GAAGe,GAAG,CAACC,eAAe,CAAC/B,IAAI,CAAC;QACnC,CAAC,CAAC,OAAOW,KAAK,EAAE;UACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;QACtD;MACF;IACF;;IAEA;IACA,IAAI,CAACI,KAAK,IAAIN,IAAI,EAAE;MAClB,IAAI;QACFG,OAAO,CAACoB,GAAG,CAAC,mEAAmE,CAAC;QAEhF,MAAMC,iBAAiB,GAAG,MAAMpD,KAAK,CAACgC,MAAM,CAAC5B,eAAe,CAAC;UAC3D6B,KAAK,EAAElC,QAAQ;UACfW,QAAQ,EAAEkB;QACZ,CAAC,CAAC;;QAEF;QACA,KAAK,MAAMO,IAAI,IAAIiB,iBAAiB,CAAChB,UAAU,CAAC,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,EAAE;UAChE,IAAIH,IAAI,CAACN,UAAU,EAAE;YACnB,MAAMlB,SAAS,GAAGwB,IAAI,CAACN,UAAU,CAACd,IAAI;YACtC,MAAMH,QAAQ,GAAGuB,IAAI,CAACN,UAAU,CAACjB,QAAQ;YAEzC,IAAI;cACF,MAAM2B,cAAc,GAAGC,IAAI,CAAC7B,SAAS,CAAC;cACtC,MAAM8B,WAAW,GAAG,IAAIC,KAAK,CAACH,cAAc,CAACI,MAAM,CAAC;cACpD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,cAAc,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;gBAC9CH,WAAW,CAACG,CAAC,CAAC,GAAGL,cAAc,CAACM,UAAU,CAACD,CAAC,CAAC;cAC/C;cACA,MAAME,SAAS,GAAG,IAAIC,UAAU,CAACN,WAAW,CAAC;cAC7C,MAAMtB,IAAI,GAAG,IAAI6B,IAAI,CAAC,CAACF,SAAS,CAAC,EAAE;gBAAE1B,IAAI,EAAER;cAAS,CAAC,CAAC;cACtDsB,KAAK,GAAGe,GAAG,CAACC,eAAe,CAAC/B,IAAI,CAAC;cACjCY,OAAO,CAACoB,GAAG,CAAC,qCAAqC,CAAC;cAClD;YACF,CAAC,CAAC,OAAOrB,KAAK,EAAE;cACdC,OAAO,CAACD,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;YAC/D;UACF;QACF;MACF,CAAC,CAAC,OAAOuB,aAAa,EAAE;QACtBtB,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEuB,aAAa,CAAC;MACnE;IACF;IAEA,OAAO;MAAEzB,IAAI;MAAEM;IAAM,CAAC;EAExB,CAAC,CAAC,OAAOJ,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IAEjD,IAAIA,KAAK,CAACwB,OAAO,IAAIxB,KAAK,CAACwB,OAAO,CAACC,QAAQ,CAAC,iBAAiB,CAAC,EAAE;MAC9D,MAAM,IAAIpD,KAAK,CAAC,oDAAoD,CAAC;IACvE,CAAC,MAAM,IAAI2B,KAAK,CAACwB,OAAO,IAAIxB,KAAK,CAACwB,OAAO,CAACC,QAAQ,CAAC,gBAAgB,CAAC,EAAE;MACpE,MAAM,IAAIpD,KAAK,CAAC,qDAAqD,CAAC;IACxE,CAAC,MAAM,IAAI2B,KAAK,CAACwB,OAAO,IAAIxB,KAAK,CAACwB,OAAO,CAACC,QAAQ,CAAC,mBAAmB,CAAC,EAAE;MACvE,MAAM,IAAIpD,KAAK,CAAC,2DAA2D,CAAC;IAC9E,CAAC,MAAM;MACL,MAAM,IAAIA,KAAK,CAAC,sBAAsB2B,KAAK,CAACwB,OAAO,IAAI,eAAe,EAAE,CAAC;IAC3E;EACF;AACF,CAAC;AAED,OAAO,MAAME,aAAa,GAAGA,CAAA,KAAM;EACjC,OAAOxD,KAAK,KAAK,IAAI;AACvB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}