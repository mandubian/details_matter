{"ast":null,"code":"import { GoogleGenerativeAI } from '@google/generative-ai';\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\nexport const initializeGoogleAI = apiKey => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  genAI = new GoogleGenerativeAI(apiKey);\n  return genAI;\n};\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n  try {\n    const model = genAI.getGenerativeModel({\n      model: MODEL_ID\n    });\n\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call in the correct format (matching documentation)\n    let contents;\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise(resolve => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        // Format matching documentation for image+text\n        contents = [{\n          text: fullPrompt\n        }, {\n          inlineData: {\n            mimeType: mimeType,\n            data: imageData\n          }\n        }];\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Fall back to text-only if image processing fails\n        contents = fullPrompt;\n      }\n    } else {\n      // Text-only format (matching documentation)\n      contents = fullPrompt;\n    }\n\n    // Generate content with image modality\n    const result = await model.generateContent({\n      contents,\n      generationConfig: {\n        responseModalities: ['Text', 'Image']\n      }\n    });\n    const response = result.response;\n\n    // Extract text and image from the response\n    let text = null;\n    let image = null;\n    if (response.candidates && response.candidates.length > 0) {\n      const candidate = response.candidates[0];\n      if (candidate.content && candidate.content.parts) {\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            text = (text || '') + part.text;\n          }\n\n          // Handle image data\n          if (part.inlineData || part.data) {\n            // Convert base64 data to blob URL\n            const imageData = part.inlineData || part;\n            if (imageData.data && imageData.mimeType) {\n              try {\n                // Create blob from base64 data\n                const byteCharacters = atob(imageData.data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                  byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], {\n                  type: imageData.mimeType\n                });\n\n                // Create object URL for the blob\n                image = URL.createObjectURL(blob);\n              } catch (error) {\n                console.error('Error processing image data:', error);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n        const imageOnlyResult = await model.generateContent({\n          contents: [{\n            parts: [{\n              text: text\n            }]\n          }],\n          generationConfig: {\n            responseModalities: ['Image']\n          }\n        });\n        const imageResponse = imageOnlyResult.response;\n        if (imageResponse.candidates && imageResponse.candidates.length > 0) {\n          const candidate = imageResponse.candidates[0];\n          if (candidate.content && candidate.content.parts) {\n            for (const part of candidate.content.parts) {\n              if (part.inlineData || part.data) {\n                const imageData = part.inlineData || part;\n                if (imageData.data && imageData.mimeType) {\n                  try {\n                    const byteCharacters = atob(imageData.data);\n                    const byteNumbers = new Array(byteCharacters.length);\n                    for (let i = 0; i < byteCharacters.length; i++) {\n                      byteNumbers[i] = byteCharacters.charCodeAt(i);\n                    }\n                    const byteArray = new Uint8Array(byteNumbers);\n                    const blob = new Blob([byteArray], {\n                      type: imageData.mimeType\n                    });\n                    image = URL.createObjectURL(blob);\n                    console.log('Fallback image generation succeeded');\n                    break;\n                  } catch (error) {\n                    console.error('Error processing fallback image data:', error);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n    return {\n      text,\n      image\n    };\n  } catch (error) {\n    console.error('Error generating content:', error);\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\nexport const isInitialized = () => {\n  return genAI !== null;\n};","map":{"version":3,"names":["GoogleGenerativeAI","MODEL_ID","genAI","initializeGoogleAI","apiKey","Error","generateContent","prompt","context","previousImage","style","model","getGenerativeModel","fullPrompt","contents","imageData","mimeType","startsWith","mime","data","split","response","fetch","blob","type","reader","FileReader","Promise","resolve","onload","result","readAsDataURL","text","inlineData","error","console","generationConfig","responseModalities","image","candidates","length","candidate","content","parts","part","byteCharacters","atob","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","Blob","URL","createObjectURL","log","imageOnlyResult","imageResponse","fallbackError","message","includes","isInitialized"],"sources":["/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/src/utils/googleAI.js"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\n\nconst MODEL_ID = \"gemini-2.5-flash-image-preview\";\n\n// Initialize the Google AI client\nlet genAI = null;\n\nexport const initializeGoogleAI = (apiKey) => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  genAI = new GoogleGenerativeAI(apiKey);\n  return genAI;\n};\n\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n\n  try {\n    const model = genAI.getGenerativeModel({ model: MODEL_ID });\n\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call in the correct format (matching documentation)\n    let contents;\n\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise((resolve) => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        // Format matching documentation for image+text\n        contents = [\n          { text: fullPrompt },\n          {\n            inlineData: {\n              mimeType: mimeType,\n              data: imageData\n            }\n          }\n        ];\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Fall back to text-only if image processing fails\n        contents = fullPrompt;\n      }\n    } else {\n      // Text-only format (matching documentation)\n      contents = fullPrompt;\n    }\n\n    // Generate content with image modality\n    const result = await model.generateContent({\n      contents,\n      generationConfig: {\n        responseModalities: ['Text', 'Image']\n      }\n    });\n\n    const response = result.response;\n\n    // Extract text and image from the response\n    let text = null;\n    let image = null;\n\n    if (response.candidates && response.candidates.length > 0) {\n      const candidate = response.candidates[0];\n\n      if (candidate.content && candidate.content.parts) {\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            text = (text || '') + part.text;\n          }\n\n          // Handle image data\n          if (part.inlineData || part.data) {\n            // Convert base64 data to blob URL\n            const imageData = part.inlineData || part;\n            if (imageData.data && imageData.mimeType) {\n              try {\n                // Create blob from base64 data\n                const byteCharacters = atob(imageData.data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                  byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], { type: imageData.mimeType });\n\n                // Create object URL for the blob\n                image = URL.createObjectURL(blob);\n              } catch (error) {\n                console.error('Error processing image data:', error);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n\n        const imageOnlyResult = await model.generateContent({\n          contents: [{\n            parts: [{ text: text }]\n          }],\n          generationConfig: {\n            responseModalities: ['Image']\n          }\n        });\n\n        const imageResponse = imageOnlyResult.response;\n\n        if (imageResponse.candidates && imageResponse.candidates.length > 0) {\n          const candidate = imageResponse.candidates[0];\n\n          if (candidate.content && candidate.content.parts) {\n            for (const part of candidate.content.parts) {\n              if (part.inlineData || part.data) {\n                const imageData = part.inlineData || part;\n                if (imageData.data && imageData.mimeType) {\n                  try {\n                    const byteCharacters = atob(imageData.data);\n                    const byteNumbers = new Array(byteCharacters.length);\n                    for (let i = 0; i < byteCharacters.length; i++) {\n                      byteNumbers[i] = byteCharacters.charCodeAt(i);\n                    }\n                    const byteArray = new Uint8Array(byteNumbers);\n                    const blob = new Blob([byteArray], { type: imageData.mimeType });\n                    image = URL.createObjectURL(blob);\n                    console.log('Fallback image generation succeeded');\n                    break;\n                  } catch (error) {\n                    console.error('Error processing fallback image data:', error);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n\n    return { text, image };\n\n  } catch (error) {\n    console.error('Error generating content:', error);\n\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\n\nexport const isInitialized = () => {\n  return genAI !== null;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}