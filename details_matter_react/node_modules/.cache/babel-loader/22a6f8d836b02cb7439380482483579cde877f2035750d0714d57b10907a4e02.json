{"ast":null,"code":"import { GoogleGenerativeAI } from '@google/generative-ai';\nconst MODEL_ID = \"gemini-1.5-flash\";\n\n// Initialize the Google AI client\nlet genAI = null;\nexport const initializeGoogleAI = apiKey => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  genAI = new GoogleGenerativeAI(apiKey);\n  return genAI;\n};\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n  try {\n    const model = genAI.getGenerativeModel({\n      model: MODEL_ID\n    });\n\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call in the correct format\n    const contentParts = [{\n      text: fullPrompt\n    }];\n\n    // Add previous image if provided\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise(resolve => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n        contentParts.push({\n          inlineData: {\n            mimeType: mimeType,\n            data: imageData\n          }\n        });\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Continue without the image if there's an error\n      }\n    }\n    const contents = [{\n      parts: contentParts\n    }];\n\n    // Generate content with image modality\n    const result = await model.generateContent({\n      contents,\n      generationConfig: {\n        responseModalities: ['Text', 'Image']\n      }\n    });\n    const response = result.response;\n\n    // Extract text and image from the response\n    let text = null;\n    let image = null;\n    if (response.candidates && response.candidates.length > 0) {\n      const candidate = response.candidates[0];\n      if (candidate.content && candidate.content.parts) {\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            text = (text || '') + part.text;\n          }\n\n          // Handle image data\n          if (part.inlineData || part.data) {\n            // Convert base64 data to blob URL\n            const imageData = part.inlineData || part;\n            if (imageData.data && imageData.mimeType) {\n              try {\n                // Create blob from base64 data\n                const byteCharacters = atob(imageData.data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                  byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], {\n                  type: imageData.mimeType\n                });\n\n                // Create object URL for the blob\n                image = URL.createObjectURL(blob);\n              } catch (error) {\n                console.error('Error processing image data:', error);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n        const imageOnlyResult = await model.generateContent({\n          contents: [{\n            parts: [{\n              text: text\n            }]\n          }],\n          generationConfig: {\n            responseModalities: ['Image']\n          }\n        });\n        const imageResponse = imageOnlyResult.response;\n        if (imageResponse.candidates && imageResponse.candidates.length > 0) {\n          const candidate = imageResponse.candidates[0];\n          if (candidate.content && candidate.content.parts) {\n            for (const part of candidate.content.parts) {\n              if (part.inlineData || part.data) {\n                const imageData = part.inlineData || part;\n                if (imageData.data && imageData.mimeType) {\n                  try {\n                    const byteCharacters = atob(imageData.data);\n                    const byteNumbers = new Array(byteCharacters.length);\n                    for (let i = 0; i < byteCharacters.length; i++) {\n                      byteNumbers[i] = byteCharacters.charCodeAt(i);\n                    }\n                    const byteArray = new Uint8Array(byteNumbers);\n                    const blob = new Blob([byteArray], {\n                      type: imageData.mimeType\n                    });\n                    image = URL.createObjectURL(blob);\n                    console.log('Fallback image generation succeeded');\n                    break;\n                  } catch (error) {\n                    console.error('Error processing fallback image data:', error);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n    return {\n      text,\n      image\n    };\n  } catch (error) {\n    console.error('Error generating content:', error);\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\nexport const isInitialized = () => {\n  return genAI !== null;\n};","map":{"version":3,"names":["GoogleGenerativeAI","MODEL_ID","genAI","initializeGoogleAI","apiKey","Error","generateContent","prompt","context","previousImage","style","model","getGenerativeModel","fullPrompt","contentParts","text","imageData","mimeType","startsWith","mime","data","split","response","fetch","blob","type","reader","FileReader","Promise","resolve","onload","result","readAsDataURL","push","inlineData","error","console","contents","parts","generationConfig","responseModalities","image","candidates","length","candidate","content","part","byteCharacters","atob","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","Blob","URL","createObjectURL","log","imageOnlyResult","imageResponse","fallbackError","message","includes","isInitialized"],"sources":["/home/mandubian/workspaces/mandubian/bananhack/details_matter_react/src/utils/googleAI.js"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\n\nconst MODEL_ID = \"gemini-1.5-flash\";\n\n// Initialize the Google AI client\nlet genAI = null;\n\nexport const initializeGoogleAI = (apiKey) => {\n  if (!apiKey) {\n    throw new Error('API key is required');\n  }\n  genAI = new GoogleGenerativeAI(apiKey);\n  return genAI;\n};\n\nexport const generateContent = async (prompt, context = \"\", previousImage = null, style = \"\") => {\n  if (!genAI) {\n    throw new Error('Google AI client not initialized. Please set your API key first.');\n  }\n\n  try {\n    const model = genAI.getGenerativeModel({ model: MODEL_ID });\n\n    // Build the full prompt\n    let fullPrompt = context ? `${context}\\n\\n${prompt}` : prompt;\n    if (style) {\n      fullPrompt += `\\nStyle: ${style}.`;\n    }\n\n    // Prepare contents for the API call in the correct format\n    const contentParts = [{ text: fullPrompt }];\n\n    // Add previous image if provided\n    if (previousImage) {\n      try {\n        // Convert blob URL or data URL to base64 for the API\n        let imageData, mimeType;\n\n        if (previousImage.startsWith('data:')) {\n          // Handle data URL\n          const [mime, data] = previousImage.split(',');\n          mimeType = mime.split(':')[1].split(';')[0];\n          imageData = data;\n        } else if (previousImage.startsWith('blob:')) {\n          // Handle blob URL - we need to fetch and convert\n          const response = await fetch(previousImage);\n          const blob = await response.blob();\n          mimeType = blob.type;\n\n          // Convert blob to base64\n          const reader = new FileReader();\n          imageData = await new Promise((resolve) => {\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.readAsDataURL(blob);\n          });\n        } else {\n          throw new Error('Unsupported image format');\n        }\n\n        contentParts.push({\n          inlineData: {\n            mimeType: mimeType,\n            data: imageData\n          }\n        });\n      } catch (error) {\n        console.error('Error processing previous image:', error);\n        // Continue without the image if there's an error\n      }\n    }\n\n    const contents = [{\n      parts: contentParts\n    }];\n\n    // Generate content with image modality\n    const result = await model.generateContent({\n      contents,\n      generationConfig: {\n        responseModalities: ['Text', 'Image']\n      }\n    });\n\n    const response = result.response;\n\n    // Extract text and image from the response\n    let text = null;\n    let image = null;\n\n    if (response.candidates && response.candidates.length > 0) {\n      const candidate = response.candidates[0];\n\n      if (candidate.content && candidate.content.parts) {\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            text = (text || '') + part.text;\n          }\n\n          // Handle image data\n          if (part.inlineData || part.data) {\n            // Convert base64 data to blob URL\n            const imageData = part.inlineData || part;\n            if (imageData.data && imageData.mimeType) {\n              try {\n                // Create blob from base64 data\n                const byteCharacters = atob(imageData.data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                  byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], { type: imageData.mimeType });\n\n                // Create object URL for the blob\n                image = URL.createObjectURL(blob);\n              } catch (error) {\n                console.error('Error processing image data:', error);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If no image was found but we have text, try to generate image-only\n    if (!image && text) {\n      try {\n        console.log('No image in initial response, attempting image-only generation...');\n\n        const imageOnlyResult = await model.generateContent({\n          contents: [{\n            parts: [{ text: text }]\n          }],\n          generationConfig: {\n            responseModalities: ['Image']\n          }\n        });\n\n        const imageResponse = imageOnlyResult.response;\n\n        if (imageResponse.candidates && imageResponse.candidates.length > 0) {\n          const candidate = imageResponse.candidates[0];\n\n          if (candidate.content && candidate.content.parts) {\n            for (const part of candidate.content.parts) {\n              if (part.inlineData || part.data) {\n                const imageData = part.inlineData || part;\n                if (imageData.data && imageData.mimeType) {\n                  try {\n                    const byteCharacters = atob(imageData.data);\n                    const byteNumbers = new Array(byteCharacters.length);\n                    for (let i = 0; i < byteCharacters.length; i++) {\n                      byteNumbers[i] = byteCharacters.charCodeAt(i);\n                    }\n                    const byteArray = new Uint8Array(byteNumbers);\n                    const blob = new Blob([byteArray], { type: imageData.mimeType });\n                    image = URL.createObjectURL(blob);\n                    console.log('Fallback image generation succeeded');\n                    break;\n                  } catch (error) {\n                    console.error('Error processing fallback image data:', error);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error('Fallback image generation failed:', fallbackError);\n      }\n    }\n\n    return { text, image };\n\n  } catch (error) {\n    console.error('Error generating content:', error);\n\n    if (error.message && error.message.includes('API_KEY_INVALID')) {\n      throw new Error('Invalid API key. Please check your Gemini API key.');\n    } else if (error.message && error.message.includes('QUOTA_EXCEEDED')) {\n      throw new Error('API quota exceeded. Please check your usage limits.');\n    } else if (error.message && error.message.includes('PERMISSION_DENIED')) {\n      throw new Error('Permission denied. Please check your API key permissions.');\n    } else {\n      throw new Error(`Generation failed: ${error.message || 'Unknown error'}`);\n    }\n  }\n};\n\nexport const isInitialized = () => {\n  return genAI !== null;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}